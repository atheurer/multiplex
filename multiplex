#!/usr/bin/perl
# -*- mode: perl; indent-tabs-mode: t; perl-indent-level: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=perl
#

use strict;
use warnings;
use Text::ParseWords;
use JSON::XS;
use Data::Dumper;

my $coder = JSON::XS->new->ascii->canonical;

# Return an array of all the valid arguments for a specific benchmark
sub get_benchmark_args {
    my $config_ref = shift; # our benchmark config
    my @args;
    for my $r (keys %{ $$config_ref{'requirements'} }) {
        @args = (@args, @{ $$config_ref{'requirements'}{$r}{"arguments"} });
    }
    return @args
}

sub get_defaults_string {
    my $defaults_ref = shift;
    my $defaults_string = "";
    foreach my $this_param (keys %$defaults_ref ) { 
        $defaults_string .= " --" . $this_param . " " . 
            join(",", @{ $$defaults_ref{$this_param} });
    }
    $defaults_string =~ s/^\s//;
    return $defaults_string;
}

# Return a string of the default parameters for a specific benchmark and default_name
sub get_benchmark_defaults {
    my $config_ref = shift; # our benchmark config
    my $default_name = shift;
    if ($default_name eq "list") {
        print "# defaults available:\n";
        for my $d (grep(!/^mandatory$/, keys %{ $$config_ref{"defaults"} })) {
            printf("# %s: %s\n", $d, get_defaults_string($$config_ref{"defaults"}{$d}));
        }
        exit;
    }
    if (exists $$config_ref{"defaults"}{$default_name}) {
        return get_defaults_string($$config_ref{"defaults"}{$default_name});
    } else {
        die "That default does not exist";
    }
}

# Validate the argument is found, the value(s) pass the regex, and any value transformations are done
# - return nothing if the tests fail
# - return the argument and values in an array if they pass
sub validate_and_transform_param {
    my $argument = shift;
    my $values = shift;
    my $param_ref = shift;
    my $processed_values = "";
    for my $r (keys %{ $$param_ref{"requirements"} }) {
        if (grep(/^$argument$/, @{ $$param_ref{"requirements"}{$r}{"arguments"} })) {
            my %past_values;
            # Users can provide multiple values
            # Using quotewords allows commas inside pair of quotes to be part of the value
            my @these_values = quotewords(',', 0, $values);
            #for my $value (quotewords(',', 0, $values)) {
            for my $value (@these_values) {
                if (exists $past_values{$value}) {
                    next;
                } else {
                    $past_values{$value} = 1;
                }

                if ($value =~ /$$param_ref{"requirements"}{$r}{"value_regex"}/) {
                    if (exists $$param_ref{"requirements"}{$r}{"value_transforms"}) {
                        my $pre_transform_value;
                        for my $transform (@{ $$param_ref{"requirements"}{$r}{"value_transforms"} }) {
                            $pre_transform_value = $value;
                            # In order to apply the 's/x/y/' regex from the file, some eval trickery
                            # is necessary
                            #
                            # Todo: first test the $transform regex separately for [perl syntax]
                            # errors with eval before doing below
                            $value = eval "\$_='$value'; $transform; return scalar \$_";
                            die "Transformation of value [" . $pre_transform_value . "] with regex [" . $transform . "] resulted in empty value\n" if (not defined $value or $value eq "");
                        }
                    }
                    # Because these will get processed again by build_iteration_cmds,
                    # single-values which have commas need to be wrapped in quotes,
                    # so they are not mis-iterpreted as mulitple values.  The quotes
                    # will be removed in build_iteration_cmds()
                    if ($value =~ /,/) {
                        $value = '"' . $value . '"';
                    }
                    if ($processed_values eq "") {
                        $processed_values = $value;
                    } else {
                        $processed_values .= ',' . $value;
                    }
                } else {
                    printf "the value, \'%s\' for argument, \'--%s\' is not valid\n", $value, $argument;
                    return;
                }
            }
            return ($argument, $processed_values);
        }
    }
    return;
}

# Recursively generate an array of all benchmark iteration cmds
sub build_iteration_cmds {
    my $cmdline = shift;
    my $multiplex_params_ref = shift; # The parameters which each value creates a new iteration
    my %multiplex_params = %$multiplex_params_ref;
    my @cmds;

    if (scalar %multiplex_params) {
        my @args = sort { $a cmp $b } (keys %multiplex_params);
        my $arg = shift(@args);
        my $values = $multiplex_params{$arg};
        delete $multiplex_params{$arg};
        # As in validate_and_transform_param(), quotewords() allows a comma to be within a single value
        # as long as it is wraped in quotes
        for my $value (quotewords(',', 0, $values)) {
            # Since these params are fully rendered (this will not be passed to
            # multiplex again), we can remove the quotes
            $value =~ s/\"//g;
            #push(@cmds, build_iteration_cmds($cmdline . " --" . $arg . " " . $value . " ",
            push(@cmds, build_iteration_cmds($cmdline . "--" . $arg . " " . $value . " ",
                 \%multiplex_params));
        }
        return @cmds;
    } else {
        return ($cmdline);
    }
}

# Shared-values are a list of values that belong to mulitple
# parameters.  Shared-values are defined by using square brackets:
# --[shared-value-name]=<value1,value2,value3>
# or
# --[shared-value-name] <value1,value2,value3>
# Shared-values are then assigned to a parameter via:
# --<param1>=[shared-value-name]
# or
# --<param1>=[shared-value-name]
#
# Shared-values result in generating benchmark commands where each command
# have parameters using the which don't
# have the value differ between these parameters within a single 
# benchmark command, for example:
#
# mulitplex <benchmark.config> --[myval]=1,2 --opt1=[myval] --opt2[myval]
# --opt1=1 opt2=1
# --opt1=2 opt2=2
#
sub handle_shared_values {
    my @ARGS = @_;

    my %param_sets;
    my @params;

    # build the iteration parameter sets and their associated shared_values
    my $current_param_set = 0;
    for my $param (@ARGS) {
        if (! exists($param_sets{$current_param_set})) {
            $param_sets{$current_param_set} = { };
            $param_sets{$current_param_set}{'iparams'} = [];
            $param_sets{$current_param_set}{'params'}  = [];
        }

        if ($param eq "--") {
            push(@{$param_sets{$current_param_set}{'params'}}, "--defaults=mandatory");
            push(@{$param_sets{$current_param_set}{'params'}}, "--");
            $current_param_set++;
        } elsif ($param =~ /^--\[.+\]/) {
            push(@{$param_sets{$current_param_set}{'iparams'}}, $param);
        } else {
            push(@{$param_sets{$current_param_set}{'params'}}, $param);
        }
    }
    # loop until all iparams have been processed, once an iparam is
    # found and processed the process needs to start over to ensure
    # that proper handling of multiple iparams is done -- if there are
    # multiple iparams in an parameter set then each iparam (and it's
    # values) are handled one at time.  when an iparam is handled a
    # new parameter set is created for each of the iparam's values.
    # the new parameter sets include any remaining iparams and the same
    # process will be done to them on a future pass
    my $do_work = 1;
    while ($do_work) {
        $do_work = 0;
        foreach my $param_hkey (sort { $a <=> $b } (keys %param_sets)) {
            if (scalar(@{$param_sets{$param_hkey}{'iparams'}})) {
                my $iparam = shift(@{$param_sets{$param_hkey}{'iparams'}});
                $iparam =~ m/^--(\[.+\])=(.+)$/;
                my $iparam_key = $1;
                my $iparam_value = $2;
                $iparam_key =~ m/\[(.+)\]/;
                my $iparam_name = $1;
                # make sure that the iparam is actually used somewhere
                my $iparam_match = 0;
                for my $param (@{$param_sets{$param_hkey}{'params'}}) {
                    if ($param eq "--") {
                        next;
                    }
                    $param =~ m/^--(.+)=(.+)$/;
                    my $param_key = $1;
                    my $param_value = $2;
                    if ($param_value =~ /\[$iparam_name\]/) {
                        $iparam_match = 1;
                        last;
                    }
                }
                if ($iparam_match) {
                    # for each iparam iteration value that is found
                    # create a new parameter set
                    for my $iparam_iter_value (quotewords(',', 0, $iparam_value)) {
                        $param_sets{$current_param_set} = { };
                        $param_sets{$current_param_set}{'iparams'} = [];
                        $param_sets{$current_param_set}{'params'}  = [];
                        push(@{$param_sets{$current_param_set}{'iparams'}},
                            @{$param_sets{$param_hkey}{'iparams'}});
                        for my $param(@{$param_sets{$param_hkey}{'params'}}) {
                            if ($param eq "--") {
                                push(@{$param_sets{$current_param_set}{'params'}}, $param);
                                next;
                            }
                            $param =~ m/^(--.+)=(.+)$/;
                            my $param_key = $1;
                            my $param_value = $2;
                            # substituate the iparam value as many
                            # times as required in the parameter value
                            $param_value =~ s/\[$iparam_name\]/$iparam_iter_value/g;
                            push(@{$param_sets{$current_param_set}{'params'}},
                            $param_key . "=" . $param_value);
                        }
                        $current_param_set++;
                    }
                    # run the loop again in case there are additional
                    # iparams to process -- the newly created
                    # parameter sets may have additional iparams
                    $do_work = 1;
                    # now that this parameter set has been processed
                    # (and new parameter sets created) it can be
                    # removed
                    delete $param_sets{$param_hkey};
                    # only process one iparam at a time before
                    # starting over so break out of the loop
                    last;
                }
            }
        }
    }
    # transform the parameter sets hash into the parameter array
    foreach my $param_key (sort { $a <=> $b } (keys %param_sets)) {
        for my $param (@{$param_sets{$param_key}{'params'}}) {
            push(@params, $param);
        }
    }
    return @params;
}

# Main program starts here

# Check for required options for multiplex
if (scalar @ARGV < 2) {
    print "You must supply at least a config file and one option\n";
    exit;
}
my $bench_config_file = shift(@ARGV);
my $json_text = "";
if (open(JSON_FH, $bench_config_file)) {
    while ( <JSON_FH> ) {
        $json_text .= $_;
    }
    close JSON_FH;
} else {
    printf "Could not open file %s\n", $bench_config_file;
    if ($bench_config_file =~ /^--.+/) {
        printf "Did you forget to provide the benchmark config file? \"%s\" does not look " .
               "like a file, but a benchmark option\n", $bench_config_file;
    }
    die;
}
my $bench_config_ref  = $coder->decode($json_text); 


# If the very next argument is "--defaults-only" then expand any "--defaults="
# and do nothing else.
my $defaults_only = 0;
if ($ARGV[0] eq "--defaults-only") {
    shift(@ARGV);
    $defaults_only = 1;
}

# Go through the @ARGS and either:
# - swap out "--defaults" with a list of default params
# - validate and transform a "--arg=val[,val]" parameter
#   - the arg needs to be a real option for the native benchmark
#   - each of the val[,val] must pass the format requirements and also might
#     get transformed

my @cmds;
my %processed_bench_params; # Benchmark-specific parameters that will have been validated/transformed
# Add a final params termination (--) if one is not present
if ($ARGV[-1] ne "--") {
    push(@ARGV, "--");
}

my @params = handle_shared_values(@ARGV);

# Now process all of the parameters
while ( scalar @params > 0 ) {
    my $param = shift @params;
    if ($param eq "--help") {
        print "These are the valid arguments:\n";
        for my $p (get_benchmark_args($bench_config_ref)) {
            printf("    --%s\n", $p);
        }
        #} elsif ($param =~ /^--defaults=(.+)$/) { # Expanded to all of the params found for that default
        #@params = (split(/\s+/, get_benchmark_defaults($bench_config_ref, $1)), @params);
    } elsif ($param =~ /^--(.+)/) { # We now have at least a partial parameter, a "--argument"
        my $arg = "";
        my $vals = "";
        if ($param =~ /^--(.+)=(.+)$/) { # We now have a full parameter, a "--argument=value"
            $arg = $1;
            $vals = $2;
        } else {
            #if ($param =~ /^--([^=\S]+)$/) { # We need the value from the next in @param
            if ($param =~ /^--(.+)$/) { # We need the value from the next in @param
                $arg = $1;
                $vals = shift @params;
            } else {
                printf "The argument %s is not formatted correctly\n", $param;
            }
        }
        if ($arg eq "defaults") {
            @params = (split(/\s+/, get_benchmark_defaults($bench_config_ref, $vals)), @params);
        } else {
            my @p;
            if (@p = validate_and_transform_param($arg, $vals, $bench_config_ref)) {
                $processed_bench_params{$p[0]} = $p[1];
            } else {
                printf "The parameter %s did not fit the requirements of the benchmark\n",
                    $param;
                exit 1;
            }
        }
    # A "--" terminates a set of options that generate a combination of iterations. One can provide
    # mulitple sets of parameters to generate multiple iterations.  For example, for fio, this
    # allows the user to have some iterations with --rw=read using --bs=64k,256 and --rw=randread
    # using bs=4k, all within the same run.
    } elsif ($param eq "--") {
        if ($defaults_only) {
            # Only output the processed params without expanding into multiple iterations
            my $cmd = "";
            for my $arg (keys %processed_bench_params) {
                $cmd .= sprintf "--%s=%s ", $arg, $processed_bench_params{$arg};
            }
            $cmd =~ s/\s$//;
            push(@cmds, $cmd);
        } else {
            # Output the processed params with expanding into multiple iterations
            @cmds = (@cmds, build_iteration_cmds("", \%processed_bench_params));
            %processed_bench_params = ();
        }
    } else {
        printf "The format of \'%s\' is not valid\n", $param;
        exit 1;
    }
}

# Print all of the iterations
for my $cmd (@cmds) {
    print "$cmd\n";
}
